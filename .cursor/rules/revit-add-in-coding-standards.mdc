---
alwaysApply: true
---

# PE_Tools Revit Add-in Development Rules

## ARCHITECTURE

- Use Shared Projects over Class Libraries for multi-target compatibility (net48
  for R23/R24, net8.0 for R25+)
- Main project (PE_Tools) orchestrates UI, business logic goes in shared
  projects
- File names MUST match class names, namespaces MUST map to folder structure
- Each add-in gets its own shared project unless using library/Nuget patterns

## CODE STYLE - NEVER-NESTERS & FAIL-FAST

- **DON'T nest more than 2 layers deep generally, ESPECIALLY with `if`
  statements.** 3 layer nesting is permissible but discouraged otherwise.
- Avoid `else if` and `else` - use pattern matching with `switch` instead
- Use separate `if` statements for multiple conditions
- Solve nesting: 1) extract to functions, 2) invert conditions with early
  returns
- Throw descriptive Exceptions for critical dependencies instead of broad `if`
  checks

## GENERAL PREFERENCES

- **We LOVE the Strategy Pattern, interfaces are your friend and inheiritance is
  the devil.** You can dance with the devil if it reduces boilerplate, but more
  than 3 layers of it and you've gone much too far.
- Prefer dependency injection over internal instantiation
- Use LINQ and Fluent APIs
- Use generic types in primitive/library functions
- Favor sequential calls over deeply nested method chains
- Extension methods and private members are invaluable for reducing public API
  surface

## WPF & UI (ALWAYS use WPF + CommunityToolkit.Mvvm)

- Use singletons for stateful add-ins (startup performance)
- Class order: constructor > properties > commands > methods
- Cast DataContext in code-behind:
  `private MyViewModel _viewModel => DataContext as MyViewModel;`

## REVIT ADD-IN PATTERNS

- Cmd[Name].cs files in main project implement IExternalCommand
- Call shared project code from cmd files
- App.cs handles IExternalApplication and creates Revit UI
- Place complex add-in code in LibraryAddins/Addin[Name]/ folders

## PROJECT STRUCTURE

- Library/ - reusable shared projects (PeRevit.Lib, PeRevit.Mep, etc.)
- LibraryAddins/ - complex add-in implementations
- PE_Tools/ - main orchestrating project
- Always use Shared.props for shared project properties

## PERFORMANCE & SECURITY

- Handle errors early with guard clauses
- Use custom error types with structured messages
- Implement comprehensive testing (unit, integration, e2e)
- Validate all inputs, use HTTPS, implement proper auth
- Optimize for Core Web Vitals and efficient queries
