
Here is a *partial* representation of the folder structure for this project

```markdown
PE_Tools/
‚îú‚îÄ‚îÄ build.cmd                <-- generated by Nuke
‚îú‚îÄ‚îÄ build.ps1                <-- generated by Nuke
‚îú‚îÄ‚îÄ build.sh                 <-- generated by Nuke
‚îú‚îÄ‚îÄ build/                   <-- the actual project name is `Nuke` (you see "Nuke" in solution explorer)
‚îÇ   ‚îú‚îÄ‚îÄ Build.cs <-- nuke build definition file
‚îú‚îÄ‚îÄ Library/                 <-- shared projects containing reusable libraries
‚îÇ   ‚îú‚îÄ‚îÄ PeRevit.Lib/              <-- core library of reusable methods and business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Commands.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Exceptions.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Faces.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Filters.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Levels.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Pickers.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Result.cs
‚îÇ   ‚îú‚îÄ‚îÄ PeMech/             <-- mechanical systems library
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Ducts.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Enums.cs
‚îÇ   ‚îú‚îÄ‚îÄ PeMep/              <-- MEP systems library
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Connectors.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ MepCurve.cs
‚îÇ   ‚îú‚îÄ‚îÄ PeRevit.Ui/          <-- infrastructure for initializing addins
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Balloon.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ButtonDataClass.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Ribbon.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ UiHelpers.cs
‚îÇ   ‚îú‚îÄ‚îÄ PeRevit.Utils/       <-- Revit-specific utility methods
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Utils.cs
‚îÇ   ‚îú‚îÄ‚îÄ PeUtils/            <-- general utility methods
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Files.cs
‚îÇ   ‚îî‚îÄ‚îÄ Shared.props        <-- shared project properties
‚îú‚îÄ‚îÄ LibraryAddins/          <-- folder addin-specific code that wont fit in a cmd[AddinName].cs file in the PE_Tools project
‚îÇ   ‚îú‚îÄ‚îÄ AddinCmdPalette/    <-- command palette addin
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Helpers/        <-- stateful addins should use singletons where necessary (for startup perf)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ KeyboardShortcutsHelper.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PostableCommandHelper.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PostableCommandItem.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ViewModels/     <-- ALWAYS USE CommunityToolkit.Mvvm
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CommandPaletteViewModel.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Views/          <-- ALWAYS USE WPF 
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CommandPaletteWindow.xaml
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CommandPaletteWindow.xaml.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ   ‚îú‚îÄ‚îÄ Addin[ComplexAddinName]/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ...
‚îÇ   ‚îî‚îÄ‚îÄ Shared.props        <-- shared project properties
‚îú‚îÄ‚îÄ PE_Tools/                <-- main project (all others are shared projects)
‚îÇ   ‚îú‚îÄ‚îÄ App.cs               <-- IExternalApplication, make Revit menu UI here with all cmd[AddinName].cs files
‚îÇ   ‚îú‚îÄ‚îÄ cmdUpdate.cs         <-- file for update addin
‚îÇ   ‚îú‚îÄ‚îÄ cmdCommandPalette.cs <-- file for command palette addin (which will become a button in App.cs)
‚îÇ   ‚îú‚îÄ‚îÄ cmd[ComplexAddinName].cs      <-- file for another addin
‚îÇ   ‚îú‚îÄ‚îÄ cmd[AddinName].cs      <-- file for another addin
‚îÇ   ‚îú‚îÄ‚îÄ Common/              <-- common code and global usings
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GlobalUsing.cs
‚îÇ   ‚îú‚îÄ‚îÄ NukeFiles/           <-- files used by InnoSetup to generate the exe installer 
‚îÇ   ‚îú‚îÄ‚îÄ PE_Tools.addin       <-- file that Revit needs to register an addin
‚îÇ   ‚îú‚îÄ‚îÄ PE_Tools.csproj
‚îÇ   ‚îú‚îÄ‚îÄ PostBuildActions.ps1 <-- used in csproj to copy dlls locally
‚îÇ   ‚îú‚îÄ‚îÄ PostBuildActionsUndo.ps1 <-- undo local dev copy of dlls
‚îÇ   ‚îú‚îÄ‚îÄ Properties/          <-- project properties and resources
‚îÇ   ‚îú‚îÄ‚îÄ Resources/           <-- image resources for buttons
‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ PE_Tools.sln
‚îî‚îÄ‚îÄ README.md
```

# Project Structure

Always use Shared Projects over than Class Libraries. The multi-targeted nature of developing for Revit (`net48` for R23/R24 and `net8.0` for R25+) makes class libs hard to setup and manage. Shared projs are also nice because they only compile what‚Äôs needed and do not produce multiple dlls.

Orchestrate Revit add-in suite via the main project (`PE_Tools`) but put *almost all*  business logic in shared projects. *Generally*, each distinct add-in should have its own shared project. At times where this doesn‚Äôt make sense, the code for it should originate from a Nuget package or a library-like shared Project. 

This is best learnt by example. However, in the main project, the `App.cs` file (which implements Revit‚Äôs `IExternalApplication`) should instantiate Revit-based UI since it is the entry-point for the add-in suite. To do so, `App.cs` will use the `PushButtonData` from files with the name `cmd[AddinCommandName]` which implement Revit‚Äôs `IExternalCommand`. As mentioned above, `cmd[AddinCommandName]` files will (generally) call the code from their corresponding shared project.

All commonly used code should be placed in library-like shared projects. For Revit add-ins this mostly consists of UI helpers and methods that create or retrieve Revit objects. Creation/retrieval code in shared projects should be somewhat primitive and will be composed in the shared project corresponding to a specific add-in.

 

*ALWAYS* match the file‚Äôs name to the name of the class it contains. And *almost always*, namespaces should map to the files place in the folder structure. The circumstance where this may not make sense is in library-like shared projects that contain a lot of methods.

UI will use WPF with CommunityToolkit.Mvvm (CTMvvm). Always utilize CTMvvm best practices. For shared projects corresponding to an add-in, the 4 directories/namespaces should be H (helpers), M (models), V (views), VM (view-models). Most UI-containing add-ins will be relatively simple. In these cases follow the example below in the ‚ÄúCode Samples‚Äù section. For complicated UIs you may make a dependency injection container at the root namespace for the shared project. This should be a last resort though.

For classes, WPF or not, they should be physically ordered in the class‚Äôs file like so: constructor/s > properties > commands (if applicable) > methods. Enclose commands and properties in regions. ‚ÄúCommand‚Äù here refers to `[RelayCommand]`'s made using CTMvvm.

# Code Style

<aside>
üìå

- Always **prefer `if` statements without curly braces!!!**
- Avoid `else if` and `else` and use pattern matching.
- Avoid excessive nesting, particularly involving `if` statements.
- Keep namespaces/classes clean to minimize scopes
- Use LINQ, generic types, and `var` instead of the full type
</aside>

## WE ARE NEVER-NESTERS AND FAIL-FAST LOVERS.

Never-nesting means that code should not usually nest more than 2 layers deep within a method. One nest refers to one C# keyword that requires indentation. For `if`'s, this reduces the number of conditions one must remember when reading/writing code. The principle however helps readability no matter what keywords or syntax features you use.

Enforce never-nesting when:

- The top level is an `if`
- Never write a 3rd nested `if` (i.e. `if() { if() { if() { }}}`)
- Extra never write a 4th nest‚Ä¶ but still avoid writing a 3rd

Relax never-nesting when:

- The top-level is a non-`if` language construct (`for`, `switch`, lambda, etc.)

Solve your nesting problems by: 1) extracting, i.e. pulling out logic into its own function or 2) inverting, i.e. switching conditions and making an early return. The effect of inversion is also very nice because it condenses all the ‚Äúbad‚Äù paths at the top of a code block and lets the ‚Äúhappy‚Äù path stand on its own.

Relatedly, check multiple conditions using *separate* `if` statements and *generally* avoid `else if` and  `else` (though it is sometimes appropriate). Oftentimes, complicated conditionals can be replaced with pattern matching via `switch` statements. And always **prefer `if` statements without curly braces,** this also inherently encourages the aforementioned suggestions.

For critical dependencies/conditions, throw a relevant `Exception` with a descriptive message rather than plainly checking it with an `if`. These critical checks are often testing for null objects or checking/casting objects types. `if` checks in these situations often result in bad and overly broad return types which gum up your code. These critical checks should be placed at entry-points such as class constructors and event subscriptions.

```csharp
// An example illustrating some of the above code style requirements
public CommandPaletteWindow()
{
    InitializeComponent();
    this.Loaded += OnLoad;
}

private void OnLoad(object sender, RoutedEventArgs e)
{
    if (_viewModel == null)
        throw new InvalidOperationException("CommandPalette view-model is null");

    CommandListBox.SelectionChanged += (s, e) =>
    {
        if (_viewModel.SelectedCommand != null)
            CommandListBox.ScrollIntoView(_viewModel.SelectedCommand);
    };
}
```

## WE ARE NAMESPACE AND CLASS-MEMBER POLLUTION HATERS

These terms simply refer to having too many things available to you in a given context. Namespace pollution makes files hard to read and reason about, especially when pulling code from many external sources. It also allows for naming collisions to creep in which can happen under your nose and be annoying to refactor.

Class-member pollution refers to classes that have an excessive number of methods, properties, and fields. You might call also call this ‚Äúclass bloat‚Äù or refer to them as ‚Äúgod classes‚Äù, meaning that they have too much responsibility. Class-member pollution is similarly unhelpful to readability, especially in methods that feature a deeply nested call stack of internal dependencies (calls to other methods within the same class). Also - as the famous joke goes, naming sucks, and the bigger the file the harder it becomes to name things.

This is somewhat contradictory to being a never-nester since ‚Äúextraction‚Äù encourages more methods to be made. However, as with everything its about moderation and balance. Prevent pollution with the following strategies:

- **Smart `using` Directives:** Prefer fully qualifying types when they're used infrequently to reduce namespace pollution; `using` statements are fine for frequently used types.
- **Meaningful Method Extraction:** Extracted methods should add value, not simply move lines around. When extracting to un-nest, try to encapsulate well-defined responsibilities. Despite our fervent love for never-nesting, we don‚Äôt want dozens of 3 line methods sprinkled everywhere.
- **Leveraging Private Members:** Use private fields and methods to reduce your class's public API surface and encapsulate internal logic, preventing class-member pollution.
- **Flattening Call Stacks:** When increasing call stack depth, favor sequential top-level function calls over deeply nested method invocations. This is different from chaining, like ‚ÄúFluent API‚Äùs do. Chaining is cool.
- **Strategic Static Methods:** Utilize static methods for utility functions that don't depend on instance state, which helps prevent object bloat and keeps instance responsibilities focused.
- **Prefer Dependency Injection:** Pass required services or objects into a class rather than having the class instantiate them, making classes more focused and reducing implicit dependencies.

## Other Preferences

- Prioritize using LINQ (and other Fluent APIs where possible)
- utilize generic types in generic/primitve functions, such as those that you write for an internal library.
- use var most of the time

# Revit Add-in Code Samples

```csharp
// This is how the cmd[CommandName] file in the main project should look like for WPF add-ins
using AddinCmdPalette.ViewModels;
using AddinCmdPalette.Views;
using PE_Tools.Properties;
using PeRevit.Ui;

namespace PE_Tools;

[Transaction(TransactionMode.Manual)]
public class CmdCommandPalette : IExternalCommand {
    public Result Execute(
        ExternalCommandData commandData,
        ref string message,
        ElementSet elementSet
    ) {
        try {
            var uiapp = commandData.Application;
            var uidoc = uiapp.ActiveUIDocument;
            var doc = uidoc.Document;

            // 1. Create the View
            var paletteWindow = new CommandPaletteWindow();

            // 2. Create the ViewModel, passing dependencies
            var viewModel = new CommandPaletteViewModel(commandData.Application);

            // 3. Set the DataContext directly (this is standard practice)
            paletteWindow.DataContext = viewModel;

            // 4. Show the View
            paletteWindow.Show();

            return Result.Succeeded;
        } catch (Exception ex) {
            throw new InvalidOperationException($"Error opening command palette: {ex.Message}");
        }
    }

    internal static PushButtonData GetButtonData() =>
        new ButtonDataClass(
            "Command Palette",
            MethodBase.GetCurrentMethod()?.DeclaringType?.FullName,
            Resources.Yellow_32,
            Resources.Yellow_16,
            "Open the command palette to search and execute Revit commands quickly. Use Ctrl+K for quick access."
        ).Data;
}

// and in the code-behind for the view you'll need to cast the DataContext
// This would be located in a shared project in a `V` directory
public partial class CommandPaletteWindow : Window
{
   ...
   private CommandPaletteViewModel _viewModel
	    {
	        get => DataContext as CommandPaletteViewModel;
	    }
   ...
}
```

# Build Pipeline

The build pipeline for this solution uses Nuke at it‚Äôs core, which allows you to construct build pipelines in code (rather than in yaml). The biggest benefit of this approach is its debuggability and reproducibility, making it easy to integrate with Github Actions. We specifically use a Nuke wrapper called ricaun.Nuke.PackageBuilder which is tailored for Revit add-in builds. This package:

- Makes the ApplicationPlugins `.bundle` folder format that Autodesk recommends.
- Makes an installer to install the bundle using InnoSetup
- Can code sign the exe (if you want).
- Has **GitHub releases** integration
- Provides **cross-platform** build scripts
- Outputs:
    1. **Compiled assemblies** for each Revit version in `bin/Release/{RevitVersion}/`
    2. **Bundle files** (`.bundle` folder) for Revit Package Manager
    3. **Installer files** (`.exe`) using InnoSetup
    4. **Zipped releases** ready for distribution

Simply run `nuke` to run a build and bundle.

# Folder Structure
    4. **Zipped releases** ready for distribution

Simply run `nuke` to run a build and bundle.

# Folder Structure